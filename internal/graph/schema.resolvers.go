package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/cleanbuddy/backend/internal/graph/generated"
	"github.com/cleanbuddy/backend/internal/graph/model"
	"github.com/cleanbuddy/backend/internal/middleware"
	"github.com/cleanbuddy/backend/internal/models"
	"github.com/google/uuid"
)

// Client is the resolver for the client field.
func (r *bookingResolver) Client(ctx context.Context, obj *model.Booking) (*model.User, error) {
	// Fetch the user by clientId
	user, err := r.AuthService.GetUserByID(obj.ClientID)
	if err != nil {
		return nil, err
	}
	return convertUserToGraphQL(user), nil
}

// Cleaner is the resolver for the cleaner field.
func (r *bookingResolver) Cleaner(ctx context.Context, obj *model.Booking) (*model.User, error) {
	if obj.CleanerID == nil || *obj.CleanerID == "" {
		return nil, nil
	}
	// Get cleaner by ID (CleanerID is the cleaner table ID, not user ID)
	cleaner, err := r.CleanerService.GetCleanerByID(*obj.CleanerID)
	if err != nil {
		return nil, err
	}
	if cleaner == nil {
		return nil, nil
	}
	// Now get the user using the cleaner's UserID
	user, err := r.AuthService.GetUserByID(cleaner.UserID)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, nil
	}
	return convertUserToGraphQL(user), nil
}

// Address is the resolver for the address field.
func (r *bookingResolver) Address(ctx context.Context, obj *model.Booking) (*model.Address, error) {
	// Fetch the address using the addressId
	// Use the clientId from the booking since they already have access to this booking
	address, err := r.AddressService.GetAddress(obj.AddressID, obj.ClientID)
	if err != nil {
		return nil, err
	}
	return convertAddressToGraphQL(address), nil
}

// RequestOtp is the resolver for the requestOtp field.
func (r *mutationResolver) RequestOtp(ctx context.Context, email string) (bool, error) {
	err := r.AuthService.RequestOTP(ctx, email)
	if err != nil {
		return false, err
	}
	return true, nil
}

// LoginWithOtp is the resolver for the loginWithOtp field.
func (r *mutationResolver) LoginWithOtp(ctx context.Context, email string, code string) (*model.Session, error) {
	token, user, err := r.AuthService.LoginWithOTP(ctx, email, code)
	if err != nil {
		return nil, err
	}

	// Set httpOnly cookie for secure JWT storage
	if w, ok := middleware.GetResponseWriter(ctx); ok {
		// Use cookie helper to set secure cookie
		setAuthCookie(w, token)
	}

	// Still return token for backwards compatibility with existing clients
	// New clients should ignore this and rely on the cookie
	return &model.Session{
		Token: token,
		User:  convertUserToGraphQL(user),
	}, nil
}

// LoginAsCleanerWithOtp is the resolver for the loginAsCleanerWithOtp field.
func (r *mutationResolver) LoginAsCleanerWithOtp(ctx context.Context, email string, code string) (*model.Session, error) {
	token, user, err := r.AuthService.LoginWithOTPWithRole(ctx, email, code, models.RoleCleaner)
	if err != nil {
		return nil, err
	}

	// Set httpOnly cookie for secure JWT storage
	if w, ok := middleware.GetResponseWriter(ctx); ok {
		setAuthCookie(w, token)
	}

	return &model.Session{
		Token: token,
		User:  convertUserToGraphQL(user),
	}, nil
}

// LoginAsCompanyWithOtp is the resolver for the loginAsCompanyWithOtp field.
func (r *mutationResolver) LoginAsCompanyWithOtp(ctx context.Context, email string, code string) (*model.Session, error) {
	token, user, err := r.AuthService.LoginWithOTPWithRole(ctx, email, code, models.RoleCompanyAdmin)
	if err != nil {
		return nil, err
	}

	// Set httpOnly cookie for secure JWT storage
	if w, ok := middleware.GetResponseWriter(ctx); ok {
		setAuthCookie(w, token)
	}

	return &model.Session{
		Token: token,
		User:  convertUserToGraphQL(user),
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// Clear the auth cookie
	if w, ok := middleware.GetResponseWriter(ctx); ok {
		clearAuthCookie(w)
	}
	return true, nil
}

// UpdateClientProfile is the resolver for the updateClientProfile field.
func (r *mutationResolver) UpdateClientProfile(ctx context.Context, input model.UpdateClientProfileInput) (*model.Client, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	client, err := r.ClientService.UpdateClientProfile(userID, input.FirstName, input.LastName, input.PhoneNumber, input.PreferredLanguage)
	if err != nil {
		return nil, err
	}

	return convertClientToGraphQL(client), nil
}

// CreateAddress is the resolver for the createAddress field.
func (r *mutationResolver) CreateAddress(ctx context.Context, input model.CreateAddressInput) (*model.Address, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Handle optional fields
	isDefault := false
	if input.IsDefault != nil {
		isDefault = *input.IsDefault
	}

	apartment := ""
	if input.Apartment != nil {
		apartment = *input.Apartment
	}

	postalCode := ""
	if input.PostalCode != nil {
		postalCode = *input.PostalCode
	}

	additionalInfo := ""
	if input.AdditionalInfo != nil {
		additionalInfo = *input.AdditionalInfo
	}

	address, err := r.AddressService.CreateAddress(userID, input.Label, input.StreetAddress, apartment, input.City, input.County, postalCode, additionalInfo, isDefault)
	if err != nil {
		return nil, err
	}

	return convertAddressToGraphQL(address), nil
}

// UpdateAddress is the resolver for the updateAddress field.
func (r *mutationResolver) UpdateAddress(ctx context.Context, id string, input model.UpdateAddressInput) (*model.Address, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	address, err := r.AddressService.UpdateAddress(id, userID, input.Label, input.StreetAddress, input.Apartment, input.City, input.County, input.PostalCode, input.AdditionalInfo, input.IsDefault)
	if err != nil {
		return nil, err
	}

	return convertAddressToGraphQL(address), nil
}

// DeleteAddress is the resolver for the deleteAddress field.
func (r *mutationResolver) DeleteAddress(ctx context.Context, id string) (bool, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return false, fmt.Errorf("authentication required")
	}

	err := r.AddressService.DeleteAddress(id, userID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateCleanerProfile is the resolver for the createCleanerProfile field.
func (r *mutationResolver) CreateCleanerProfile(ctx context.Context, input model.CreateCleanerProfileInput) (*model.Cleaner, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	cleaner, err := r.CleanerService.CreateCleanerProfile(userID, input.PhoneNumber, input.DateOfBirth, input.StreetAddress, input.City, input.County, input.PostalCode, input.YearsOfExperience, input.Bio, input.Specializations, input.Languages)
	if err != nil {
		return nil, err
	}

	return convertCleanerToGraphQL(cleaner), nil
}

// UpdateCleanerProfile is the resolver for the updateCleanerProfile field.
func (r *mutationResolver) UpdateCleanerProfile(ctx context.Context, input model.UpdateCleanerProfileInput) (*model.Cleaner, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	cleaner, err := r.CleanerService.UpdateCleanerProfile(userID, input.PhoneNumber, input.DateOfBirth, input.StreetAddress, input.City, input.County, input.PostalCode, input.YearsOfExperience, input.Bio, &input.Specializations, &input.Languages, input.Iban, input.IsAvailable)
	if err != nil {
		return nil, err
	}

	return convertCleanerToGraphQL(cleaner), nil
}

// UploadCleanerDocument is the resolver for the uploadCleanerDocument field.
func (r *mutationResolver) UploadCleanerDocument(ctx context.Context, documentType string, fileURL string) (*model.Cleaner, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	cleaner, err := r.CleanerService.UploadDocument(userID, documentType, fileURL)
	if err != nil {
		return nil, err
	}

	return convertCleanerToGraphQL(cleaner), nil
}

// CreateBooking is the resolver for the createBooking field.
func (r *mutationResolver) CreateBooking(ctx context.Context, input model.CreateBookingInput) (*model.Booking, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Handle optional fields
	areaSqm := 0
	if input.AreaSqm != nil {
		areaSqm = *input.AreaSqm
	}

	specialInstructions := ""
	if input.SpecialInstructions != nil {
		specialInstructions = *input.SpecialInstructions
	}

	accessInstructions := ""
	if input.AccessInstructions != nil {
		accessInstructions = *input.AccessInstructions
	}

	// Handle time preferences or scheduled date/time
	var scheduledDate, scheduledTime time.Time
	if input.ScheduledDate != nil && input.ScheduledTime != nil {
		scheduledDate = *input.ScheduledDate
		scheduledTime = *input.ScheduledTime
	}
	// Note: If timePreferences is provided instead, cleaner will choose final date/time later

	timePreferences := ""
	if input.TimePreferences != nil {
		timePreferences = *input.TimePreferences
	}

	frequency := ""
	if input.Frequency != nil {
		frequency = *input.Frequency
	}

	includesFridge := false
	if input.IncludesFridge != nil {
		includesFridge = *input.IncludesFridge
	}

	includesOven := false
	if input.IncludesOven != nil {
		includesOven = *input.IncludesOven
	}

	includesBalcony := false
	if input.IncludesBalcony != nil {
		includesBalcony = *input.IncludesBalcony
	}

	booking, err := r.BookingService.CreateBooking(userID, input.AddressID, models.ServiceType(input.ServiceType), areaSqm, input.EstimatedHours, scheduledDate, scheduledTime, input.IncludesDeepCleaning, input.IncludesWindows, input.NumberOfWindows, input.IncludesCarpet, input.CarpetAreaSqm, includesFridge, includesOven, includesBalcony, specialInstructions, accessInstructions, input.Supplies, timePreferences, frequency)
	if err != nil {
		return nil, err
	}

	return convertBookingToGraphQL(booking), nil
}

// CancelBooking is the resolver for the cancelBooking field.
func (r *mutationResolver) CancelBooking(ctx context.Context, id string, reason string) (*model.Booking, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	booking, err := r.BookingService.CancelBooking(id, userID, reason)
	if err != nil {
		return nil, err
	}

	return convertBookingToGraphQL(booking), nil
}

// ConfirmBooking is the resolver for the confirmBooking field.
func (r *mutationResolver) ConfirmBooking(ctx context.Context, id string) (*model.Booking, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	booking, err := r.BookingService.ConfirmBooking(id, userID)
	if err != nil {
		return nil, err
	}

	return convertBookingToGraphQL(booking), nil
}

// StartBooking is the resolver for the startBooking field.
func (r *mutationResolver) StartBooking(ctx context.Context, id string) (*model.Booking, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	booking, err := r.BookingService.StartBooking(id, userID)
	if err != nil {
		return nil, err
	}

	return convertBookingToGraphQL(booking), nil
}

// CompleteBooking is the resolver for the completeBooking field.
func (r *mutationResolver) CompleteBooking(ctx context.Context, id string) (*model.Booking, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	booking, err := r.BookingService.CompleteBooking(id, userID)
	if err != nil {
		return nil, err
	}

	return convertBookingToGraphQL(booking), nil
}

// AcceptBooking is the resolver for the acceptBooking field.
func (r *mutationResolver) AcceptBooking(ctx context.Context, id string, scheduledDate *time.Time, scheduledTime *time.Time) (*model.Booking, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// If scheduledDate and scheduledTime are provided, use them
	// Otherwise, the service will use existing values from the booking
	booking, err := r.BookingService.AcceptBookingWithTime(id, userID, scheduledDate, scheduledTime)
	if err != nil {
		return nil, err
	}

	return convertBookingToGraphQL(booking), nil
}

// DeclineBooking is the resolver for the declineBooking field.
func (r *mutationResolver) DeclineBooking(ctx context.Context, id string, reason *string) (bool, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return false, fmt.Errorf("authentication required")
	}

	declineReason := ""
	if reason != nil {
		declineReason = *reason
	}

	result, err := r.BookingService.DeclineBooking(id, userID, declineReason)
	if err != nil {
		return false, err
	}

	return result, nil
}

// CheckIn is the resolver for the checkIn field.
func (r *mutationResolver) CheckIn(ctx context.Context, bookingID string, latitude float64, longitude float64) (*model.Checkin, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	checkin, err := r.CheckinService.CheckIn(bookingID, userID, latitude, longitude)
	if err != nil {
		return nil, err
	}

	return convertCheckinToGraphQL(checkin), nil
}

// CheckOut is the resolver for the checkOut field.
func (r *mutationResolver) CheckOut(ctx context.Context, bookingID string, latitude float64, longitude float64) (*model.Checkin, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	checkin, err := r.CheckinService.CheckOut(bookingID, userID, latitude, longitude)
	if err != nil {
		return nil, err
	}

	return convertCheckinToGraphQL(checkin), nil
}

// PreauthorizePayment is the resolver for the preauthorizePayment field.
func (r *mutationResolver) PreauthorizePayment(ctx context.Context, bookingID string, amount float64, provider model.PaymentProvider) (*model.Payment, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Convert provider enum
	convertedProvider := models.PaymentProvider(provider)

	payment, err := r.PaymentService.PreauthorizePayment(bookingID, userID, amount, convertedProvider)
	if err != nil {
		return nil, err
	}

	return convertPaymentToGraphQL(payment), nil
}

// CapturePayment is the resolver for the capturePayment field.
func (r *mutationResolver) CapturePayment(ctx context.Context, paymentID string) (*model.Payment, error) {
	payment, err := r.PaymentService.CapturePayment(paymentID)
	if err != nil {
		return nil, err
	}

	return convertPaymentToGraphQL(payment), nil
}

// RefundPayment is the resolver for the refundPayment field.
func (r *mutationResolver) RefundPayment(ctx context.Context, paymentID string, amount float64, reason string) (*model.Payment, error) {
	payment, err := r.PaymentService.RefundPayment(paymentID, amount, reason)
	if err != nil {
		return nil, err
	}

	return convertPaymentToGraphQL(payment), nil
}

// CancelPayment is the resolver for the cancelPayment field.
func (r *mutationResolver) CancelPayment(ctx context.Context, paymentID string) (*model.Payment, error) {
	payment, err := r.PaymentService.CancelPreauthorization(paymentID)
	if err != nil {
		return nil, err
	}

	return convertPaymentToGraphQL(payment), nil
}

// CreateAvailability is the resolver for the createAvailability field.
func (r *mutationResolver) CreateAvailability(ctx context.Context, input model.CreateAvailabilityInput) (*model.Availability, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Get cleaner profile
	cleaner, err := r.CleanerService.GetOrCreateCleanerProfile(userID)
	if err != nil {
		return nil, err
	}

	availability, err := r.AvailabilityService.CreateAvailability(
		cleaner.ID,
		string(input.Type),
		input.DayOfWeek,
		input.SpecificDate,
		input.StartTime,
		input.EndTime,
		input.IsActive,
		input.Notes,
	)
	if err != nil {
		return nil, err
	}

	return convertAvailabilityToGraphQL(availability), nil
}

// UpdateAvailability is the resolver for the updateAvailability field.
func (r *mutationResolver) UpdateAvailability(ctx context.Context, id string, input model.UpdateAvailabilityInput) (*model.Availability, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Get cleaner profile
	cleaner, err := r.CleanerService.GetOrCreateCleanerProfile(userID)
	if err != nil {
		return nil, err
	}

	availability, err := r.AvailabilityService.UpdateAvailability(
		id,
		cleaner.ID,
		input.StartTime,
		input.EndTime,
		input.IsActive,
		input.Notes,
	)
	if err != nil {
		return nil, err
	}

	return convertAvailabilityToGraphQL(availability), nil
}

// DeleteAvailability is the resolver for the deleteAvailability field.
func (r *mutationResolver) DeleteAvailability(ctx context.Context, id string) (bool, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return false, fmt.Errorf("authentication required")
	}

	// Get cleaner profile
	cleaner, err := r.CleanerService.GetOrCreateCleanerProfile(userID)
	if err != nil {
		return false, err
	}

	err = r.AvailabilityService.DeleteAvailability(id, cleaner.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateCompany is the resolver for the createCompany field.
func (r *mutationResolver) CreateCompany(ctx context.Context, input model.CreateCompanyInput) (*model.Company, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	company, err := r.CompanyService.CreateCompany(
		userID,
		input.Name,
		input.Cui,
		input.RegistrationNumber,
		input.Iban,
		input.BankName,
		input.LegalAddress,
		input.ContactEmail,
		input.ContactPhone,
	)
	if err != nil {
		return nil, err
	}

	return convertCompanyToGraphQL(company), nil
}

// UpdateCompany is the resolver for the updateCompany field.
func (r *mutationResolver) UpdateCompany(ctx context.Context, id string, input model.UpdateCompanyInput) (*model.Company, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	company, err := r.CompanyService.UpdateCompany(
		id,
		userID,
		input.Name,
		input.Iban,
		input.BankName,
		input.LegalAddress,
		input.ContactEmail,
		input.ContactPhone,
	)
	if err != nil {
		return nil, err
	}

	return convertCompanyToGraphQL(company), nil
}

// AddCleanerToCompany is the resolver for the addCleanerToCompany field.
func (r *mutationResolver) AddCleanerToCompany(ctx context.Context, companyID string, cleanerID string) (*model.CompanyCleaner, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	companyCleaner, err := r.CompanyService.AddCleanerToCompany(companyID, cleanerID, userID)
	if err != nil {
		return nil, err
	}

	return convertCompanyCleanerToGraphQL(companyCleaner, r.Resolver), nil
}

// RemoveCleanerFromCompany is the resolver for the removeCleanerFromCompany field.
func (r *mutationResolver) RemoveCleanerFromCompany(ctx context.Context, companyID string, cleanerID string) (bool, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return false, fmt.Errorf("authentication required")
	}

	err := r.CompanyService.RemoveCleanerFromCompany(companyID, cleanerID, userID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UploadCompanyDocument is the resolver for the uploadCompanyDocument field.
func (r *mutationResolver) UploadCompanyDocument(ctx context.Context, companyID string, documentType string, fileURL string) (*model.Company, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	company, err := r.CompanyService.UploadCompanyDocument(companyID, userID, documentType, fileURL)
	if err != nil {
		return nil, err
	}

	return convertCompanyToGraphQL(company), nil
}

// ApproveCleanerProfile is the resolver for the approveCleanerProfile field.
func (r *mutationResolver) ApproveCleanerProfile(ctx context.Context, cleanerID string) (*model.Cleaner, error) {
	// Require admin authorization
	userID, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	cleaner, err := r.CleanerService.ApproveCleanerProfile(cleanerID, userID)
	if err != nil {
		return nil, err
	}

	return convertCleanerToGraphQL(cleaner), nil
}

// RejectCleanerProfile is the resolver for the rejectCleanerProfile field.
func (r *mutationResolver) RejectCleanerProfile(ctx context.Context, cleanerID string, reason string) (*model.Cleaner, error) {
	// Require admin authorization
	userID, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	cleaner, err := r.CleanerService.RejectCleanerProfile(cleanerID, userID, reason)
	if err != nil {
		return nil, err
	}

	return convertCleanerToGraphQL(cleaner), nil
}

// ApproveCompany is the resolver for the approveCompany field.
func (r *mutationResolver) ApproveCompany(ctx context.Context, companyID string) (*model.Company, error) {
	// Require admin authorization
	userID, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	company, err := r.CompanyService.ApproveCompany(companyID, userID)
	if err != nil {
		return nil, err
	}

	return convertCompanyToGraphQL(company), nil
}

// RejectCompany is the resolver for the rejectCompany field.
func (r *mutationResolver) RejectCompany(ctx context.Context, companyID string, reason string) (*model.Company, error) {
	// Require admin authorization
	userID, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	company, err := r.CompanyService.RejectCompany(companyID, userID, reason)
	if err != nil {
		return nil, err
	}

	return convertCompanyToGraphQL(company), nil
}

// SuspendCleaner is the resolver for the suspendCleaner field.
func (r *mutationResolver) SuspendCleaner(ctx context.Context, cleanerID string, reason string) (*model.Cleaner, error) {
	// Require admin authorization
	adminID, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	cleaner, err := r.CleanerService.SuspendCleaner(cleanerID, adminID, reason)
	if err != nil {
		return nil, err
	}

	return convertCleanerToGraphQL(cleaner), nil
}

// ActivateCleaner is the resolver for the activateCleaner field.
func (r *mutationResolver) ActivateCleaner(ctx context.Context, cleanerID string) (*model.Cleaner, error) {
	// Require admin authorization
	adminID, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	cleaner, err := r.CleanerService.ActivateCleaner(cleanerID, adminID)
	if err != nil {
		return nil, err
	}

	return convertCleanerToGraphQL(cleaner), nil
}

// ToggleCleanerAvailability is the resolver for the toggleCleanerAvailability field.
func (r *mutationResolver) ToggleCleanerAvailability(ctx context.Context, cleanerID string) (*model.Cleaner, error) {
	// Require admin authorization
	adminID, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	cleaner, err := r.CleanerService.ToggleCleanerAvailability(cleanerID, adminID)
	if err != nil {
		return nil, err
	}

	return convertCleanerToGraphQL(cleaner), nil
}

// VerifyCleanerDocument is the resolver for the verifyCleanerDocument field.
func (r *mutationResolver) VerifyCleanerDocument(ctx context.Context, cleanerID string, documentType string) (*model.Cleaner, error) {
	// Require admin authorization
	adminID, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	cleaner, err := r.CleanerService.VerifyCleanerDocument(cleanerID, adminID, documentType)
	if err != nil {
		return nil, err
	}

	return convertCleanerToGraphQL(cleaner), nil
}

// ReassignBooking is the resolver for the reassignBooking field.
func (r *mutationResolver) ReassignBooking(ctx context.Context, bookingID string, cleanerID string) (*model.Booking, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	booking, err := r.BookingService.AdminReassignBooking(bookingID, cleanerID)
	if err != nil {
		return nil, err
	}

	return convertBookingToGraphQL(booking), nil
}

// AdminCancelBooking is the resolver for the adminCancelBooking field.
func (r *mutationResolver) AdminCancelBooking(ctx context.Context, bookingID string, reason string) (*model.Booking, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	booking, err := r.BookingService.AdminCancelBooking(bookingID, reason)
	if err != nil {
		return nil, err
	}

	return convertBookingToGraphQL(booking), nil
}

// AdminUpdateBookingStatus is the resolver for the adminUpdateBookingStatus field.
func (r *mutationResolver) AdminUpdateBookingStatus(ctx context.Context, bookingID string, status model.BookingStatus) (*model.Booking, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	// Convert GraphQL status to models status
	modelStatus := models.BookingStatus(status)
	booking, err := r.BookingService.AdminUpdateBookingStatus(bookingID, modelStatus)
	if err != nil {
		return nil, err
	}

	return convertBookingToGraphQL(booking), nil
}

// AdminEditBooking is the resolver for the adminEditBooking field.
func (r *mutationResolver) AdminEditBooking(ctx context.Context, bookingID string, input model.AdminEditBookingInput) (*model.Booking, error) {
	panic(fmt.Errorf("not implemented: AdminEditBooking - adminEditBooking"))
}

// CreateReview is the resolver for the createReview field.
func (r *mutationResolver) CreateReview(ctx context.Context, input model.CreateReviewInput) (*model.Review, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	comment := ""
	if input.Comment != nil {
		comment = *input.Comment
	}

	review, err := r.ReviewService.CreateReview(input.BookingID, userID, input.Rating, comment)
	if err != nil {
		return nil, err
	}

	return convertReviewToGraphQL(review), nil
}

// CreateDispute is the resolver for the createDispute field.
func (r *mutationResolver) CreateDispute(ctx context.Context, input model.CreateDisputeInput) (*model.Dispute, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	dispute, err := r.DisputeService.CreateDispute(input.BookingID, userID, string(input.DisputeType), input.Description)
	if err != nil {
		return nil, err
	}

	return convertDisputeToGraphQL(dispute), nil
}

// AddCleanerResponse is the resolver for the addCleanerResponse field.
func (r *mutationResolver) AddCleanerResponse(ctx context.Context, disputeID string, response string) (*model.Dispute, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	dispute, err := r.DisputeService.AddCleanerResponse(disputeID, userID, response)
	if err != nil {
		return nil, err
	}

	return convertDisputeToGraphQL(dispute), nil
}

// ResolveDispute is the resolver for the resolveDispute field.
func (r *mutationResolver) ResolveDispute(ctx context.Context, disputeID string, input model.ResolveDisputeInput) (*model.Dispute, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Check if user is admin (PLATFORM_ADMIN role)
	user, err := r.AuthService.GetUserByID(userID)
	if err != nil {
		return nil, err
	}
	if user == nil || user.Role != "PLATFORM_ADMIN" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	refundAmount := 0.0
	if input.RefundAmount != nil {
		refundAmount = *input.RefundAmount
	}

	dispute, err := r.DisputeService.ResolveDispute(disputeID, userID, string(input.ResolutionType), input.ResolutionNotes, refundAmount)
	if err != nil {
		return nil, err
	}

	return convertDisputeToGraphQL(dispute), nil
}

// UploadPhoto is the resolver for the uploadPhoto field.
func (r *mutationResolver) UploadPhoto(ctx context.Context, file graphql.Upload, bookingID string, photoType model.PhotoType) (*model.Photo, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	photo, err := r.PhotoService.UploadPhoto(file, bookingID, userID, string(photoType))
	if err != nil {
		return nil, err
	}

	return convertPhotoToGraphQL(photo), nil
}

// UploadDisputePhoto is the resolver for the uploadDisputePhoto field.
func (r *mutationResolver) UploadDisputePhoto(ctx context.Context, file graphql.Upload, disputeID string) (*model.Photo, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	photo, err := r.PhotoService.UploadDisputePhoto(file, disputeID, userID)
	if err != nil {
		return nil, err
	}

	return convertPhotoToGraphQL(photo), nil
}

// DeletePhoto is the resolver for the deletePhoto field.
func (r *mutationResolver) DeletePhoto(ctx context.Context, id string) (bool, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return false, fmt.Errorf("authentication required")
	}

	if err := r.PhotoService.DeletePhoto(id); err != nil {
		return false, err
	}

	return true, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, input model.SendMessageInput) (*model.Message, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	message, err := r.MessagingService.SendMessage(input.BookingID, userID, input.ReceiverID, input.Content)
	if err != nil {
		return nil, err
	}

	return convertMessageToGraphQL(message), nil
}

// MarkMessagesAsRead is the resolver for the markMessagesAsRead field.
func (r *mutationResolver) MarkMessagesAsRead(ctx context.Context, bookingID string) (bool, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return false, fmt.Errorf("authentication required")
	}

	if err := r.MessagingService.MarkMessagesAsRead(bookingID, userID); err != nil {
		return false, err
	}

	return true, nil
}

// GenerateMonthlyPayouts is the resolver for the generateMonthlyPayouts field.
func (r *mutationResolver) GenerateMonthlyPayouts(ctx context.Context, input model.GeneratePayoutsInput) ([]*model.Payout, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Check if user is admin
	user, err := r.AuthService.GetUserByID(userID)
	if err != nil {
		return nil, err
	}
	if user == nil || user.Role != "PLATFORM_ADMIN" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	payouts, err := r.PayoutService.GenerateMonthlyPayouts(input.Year, time.Month(input.Month))
	if err != nil {
		return nil, err
	}

	result := make([]*model.Payout, len(payouts))
	for i, payout := range payouts {
		result[i] = convertPayoutToGraphQL(payout)
	}

	return result, nil
}

// MarkPayoutAsSent is the resolver for the markPayoutAsSent field.
func (r *mutationResolver) MarkPayoutAsSent(ctx context.Context, id string, transferReference string) (*model.Payout, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	if err := r.PayoutService.MarkPayoutAsSent(id, transferReference); err != nil {
		return nil, err
	}

	payout, lineItems, err := r.PayoutService.GetPayoutWithLineItems(id)
	if err != nil {
		return nil, err
	}

	return convertPayoutToGraphQLWithLineItems(payout, lineItems), nil
}

// MarkPayoutAsFailed is the resolver for the markPayoutAsFailed field.
func (r *mutationResolver) MarkPayoutAsFailed(ctx context.Context, id string, reason string) (*model.Payout, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	if err := r.PayoutService.MarkPayoutAsFailed(id, reason); err != nil {
		return nil, err
	}

	payout, lineItems, err := r.PayoutService.GetPayoutWithLineItems(id)
	if err != nil {
		return nil, err
	}

	return convertPayoutToGraphQLWithLineItems(payout, lineItems), nil
}

// UpdatePlatformSettings is the resolver for the updatePlatformSettings field.
func (r *mutationResolver) UpdatePlatformSettings(ctx context.Context, input model.UpdatePlatformSettingsInput) (*model.PlatformSettings, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	// Get current settings
	settings, err := r.PlatformSettingsService.GetSettings(ctx)
	if err != nil {
		return nil, err
	}

	// Update fields if provided
	if input.BasePrice != nil {
		settings.BasePrice = *input.BasePrice
	}
	if input.WeekendMultiplier != nil {
		settings.WeekendMultiplier = *input.WeekendMultiplier
	}
	if input.EveningMultiplier != nil {
		settings.EveningMultiplier = *input.EveningMultiplier
	}
	if input.PlatformFeePercent != nil {
		settings.PlatformFeePercent = *input.PlatformFeePercent
	}
	if input.EmailNotificationsEnabled != nil {
		settings.EmailNotificationsEnabled = *input.EmailNotificationsEnabled
	}
	if input.AutoApprovalEnabled != nil {
		settings.AutoApprovalEnabled = *input.AutoApprovalEnabled
	}
	if input.MaintenanceMode != nil {
		settings.MaintenanceMode = *input.MaintenanceMode
	}

	// Save settings
	updated, err := r.PlatformSettingsService.UpdateSettings(ctx, settings)
	if err != nil {
		return nil, err
	}

	return convertPlatformSettingsToGraphQL(updated), nil
}

// UpdateUserProfile is the resolver for the updateUserProfile field.
func (r *mutationResolver) UpdateUserProfile(ctx context.Context, input model.UpdateUserProfileInput) (*model.User, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	user, err := r.AuthService.UpdateUserProfile(userID, input.FirstName, input.LastName, input.Email)
	if err != nil {
		return nil, err
	}

	return convertUserToGraphQL(user), nil
}

// RetryANAFSubmission is the resolver for the retryANAFSubmission field.
func (r *mutationResolver) RetryANAFSubmission(ctx context.Context, invoiceID string) (*model.Invoice, error) {
	// TODO: Add admin role check when auth middleware is ready
	// userID, ok := middleware.GetUserIDFromContext(ctx)
	// if !ok {
	// 	return nil, fmt.Errorf("unauthorized")
	// }

	// Retry ANAF submission
	if err := r.InvoiceService.SubmitToANAF(invoiceID); err != nil {
		return nil, fmt.Errorf("failed to retry ANAF submission: %w", err)
	}

	// Get updated invoice
	invoice, err := r.InvoiceService.GetInvoiceByID(invoiceID)
	if err != nil {
		return nil, fmt.Errorf("failed to get invoice: %w", err)
	}

	return convertInvoiceToGraphQL(invoice), nil
}

// CheckANAFStatus is the resolver for the checkANAFStatus field.
func (r *mutationResolver) CheckANAFStatus(ctx context.Context, invoiceID string) (*model.Invoice, error) {
	// TODO: Add admin role check when auth middleware is ready
	// userID, ok := middleware.GetUserIDFromContext(ctx)
	// if !ok {
	// 	return nil, fmt.Errorf("unauthorized")
	// }

	// Check ANAF status
	if err := r.InvoiceService.CheckANAFStatus(invoiceID); err != nil {
		return nil, fmt.Errorf("failed to check ANAF status: %w", err)
	}

	// Get updated invoice
	invoice, err := r.InvoiceService.GetInvoiceByID(invoiceID)
	if err != nil {
		return nil, fmt.Errorf("failed to get invoice: %w", err)
	}

	return convertInvoiceToGraphQL(invoice), nil
}

// SaveCleanerApplication is the resolver for the saveCleanerApplication field.
func (r *mutationResolver) SaveCleanerApplication(ctx context.Context, input model.CleanerApplicationInput) (*model.CleanerApplication, error) {
	// Get authenticated user ID if available (optional for draft saving)
	userID, _ := middleware.GetUserIDFromContext(ctx)

	// Convert GraphQL input to service input
	serviceInput := &models.CleanerApplicationInput{
		SessionID:   input.SessionID,
		CurrentStep: input.CurrentStep,
	}

	// Set user ID if authenticated
	if userID != "" {
		uid, err := uuid.Parse(userID)
		if err == nil {
			serviceInput.UserID = &uid
		}
	}

	// Convert eligibility data if provided
	if input.Eligibility != nil {
		serviceInput.Eligibility = &models.EligibilityInput{
			Age18Plus:  input.Eligibility.Age18Plus,
			WorkRight:  input.Eligibility.WorkRight,
			Experience: input.Eligibility.Experience,
		}
	}

	// Convert availability data if provided
	if input.Availability != nil {
		serviceInput.Availability = &models.AvailabilityInput{
			HoursPerWeek: input.Availability.HoursPerWeek,
			Areas:        input.Availability.Areas,
			Days:         input.Availability.Days,
			TimeSlots:    input.Availability.TimeSlots,
		}
	}

	// Convert profile data if provided
	if input.Profile != nil {
		serviceInput.Profile = &models.ProfileInput{
			PhotoURL:  input.Profile.PhotoURL,
			Bio:       input.Profile.Bio,
			Languages: input.Profile.Languages,
			Equipment: input.Profile.Equipment,
		}
	}

	// Convert legal data if provided
	if input.Legal != nil {
		serviceInput.Legal = &models.LegalInput{
			Status:       input.Legal.Status,
			CIF:          input.Legal.Cif,
			CNPEncrypted: input.Legal.CnpEncrypted,
			IBAN:         input.Legal.Iban,
			BankName:     input.Legal.BankName,
		}
	}

	// Convert documents data if provided
	if input.Documents != nil {
		serviceInput.Documents = &models.DocumentInput{
			CazierURL:    input.Documents.CazierURL,
			IDFrontURL:   input.Documents.IDFrontURL,
			IDBackURL:    input.Documents.IDBackURL,
			InsuranceURL: input.Documents.InsuranceURL,
		}
	}

	// Save application
	app, err := r.CleanerApplicationService.SaveApplication(serviceInput)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	return convertCleanerApplicationToGraphQL(app), nil
}

// SubmitCleanerApplication is the resolver for the submitCleanerApplication field.
func (r *mutationResolver) SubmitCleanerApplication(ctx context.Context, applicationID string) (*model.CleanerApplication, error) {
	// Require authentication
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Submit application
	app, err := r.CleanerApplicationService.SubmitApplication(applicationID, userID)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	return convertCleanerApplicationToGraphQL(app), nil
}

// ReviewCleanerApplication is the resolver for the reviewCleanerApplication field.
func (r *mutationResolver) ReviewCleanerApplication(ctx context.Context, applicationID string, approve bool, rejectionReason *string) (*model.CleanerApplication, error) {
	// Require admin authorization
	adminID, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	// Convert optional rejectionReason to string
	rejectionReasonStr := ""
	if rejectionReason != nil {
		rejectionReasonStr = *rejectionReason
	}

	// Review application (adminNotes empty for now, can be added to GraphQL schema later)
	app, err := r.CleanerApplicationService.ReviewApplication(applicationID, adminID, approve, rejectionReasonStr, "")
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	return convertCleanerApplicationToGraphQL(app), nil
}

// Ping is the resolver for the ping field.
func (r *queryResolver) Ping(ctx context.Context) (string, error) {
	return "pong", nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	user, err := r.AuthService.GetUserByID(userID)
	if err != nil {
		return nil, err
	}

	if user == nil {
		return nil, fmt.Errorf("user not found")
	}

	return convertUserToGraphQL(user), nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.AuthService.GetUserByID(id)
	if err != nil {
		return nil, err
	}

	if user == nil {
		return nil, fmt.Errorf("user not found")
	}

	return convertUserToGraphQL(user), nil
}

// MyClientProfile is the resolver for the myClientProfile field.
func (r *queryResolver) MyClientProfile(ctx context.Context) (*model.Client, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	client, err := r.ClientService.GetOrCreateClientProfile(userID)
	if err != nil {
		return nil, err
	}

	return convertClientToGraphQL(client), nil
}

// MyAddresses is the resolver for the myAddresses field.
func (r *queryResolver) MyAddresses(ctx context.Context) ([]*model.Address, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	addresses, err := r.AddressService.GetUserAddresses(userID)
	if err != nil {
		return nil, err
	}

	// Convert array
	result := make([]*model.Address, len(addresses))
	for i, addr := range addresses {
		result[i] = convertAddressToGraphQL(addr)
	}

	return result, nil
}

// Address is the resolver for the address field.
func (r *queryResolver) Address(ctx context.Context, id string) (*model.Address, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	address, err := r.AddressService.GetAddress(id, userID)
	if err != nil {
		return nil, err
	}

	return convertAddressToGraphQL(address), nil
}

// MyCleanerProfile is the resolver for the myCleanerProfile field.
func (r *queryResolver) MyCleanerProfile(ctx context.Context) (*model.Cleaner, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	cleaner, err := r.CleanerService.GetOrCreateCleanerProfile(userID)
	if err != nil {
		return nil, nil
	}

	return convertCleanerToGraphQL(cleaner), nil
}

// Cleaner is the resolver for the cleaner field.
func (r *queryResolver) Cleaner(ctx context.Context, id string) (*model.Cleaner, error) {
	cleaner, err := r.CleanerService.GetCleanerByID(id)
	if err != nil {
		return nil, err
	}

	if cleaner == nil {
		return nil, fmt.Errorf("cleaner not found")
	}

	return convertCleanerToGraphQL(cleaner), nil
}

// ApprovedCleaners is the resolver for the approvedCleaners field.
func (r *queryResolver) ApprovedCleaners(ctx context.Context) ([]*model.Cleaner, error) {
	// Get approved cleaners (no limit, no search filter)
	cleaners, err := r.CleanerService.GetApprovedCleaners(1000, 0, "")
	if err != nil {
		return nil, err
	}

	result := make([]*model.Cleaner, len(cleaners))
	for i, cleaner := range cleaners {
		result[i] = convertCleanerToGraphQL(cleaner)
	}

	return result, nil
}

// MyBookings is the resolver for the myBookings field.
func (r *queryResolver) MyBookings(ctx context.Context, filter *model.BookingFilter) ([]*model.Booking, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	role, ok := middleware.GetUserRoleFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("role not found")
	}

	var bookings []*models.Booking
	var err error

	// Determine which bookings to fetch based on user role
	if role == "CLEANER" {
		// Get cleaner profile
		cleaner, err := r.CleanerService.GetOrCreateCleanerProfile(userID)
		if err != nil {
			return nil, fmt.Errorf("failed to get cleaner profile: %w", err)
		}

		// Fetch cleaner's bookings using GetBookingsByCleanerIDs
		var filterStr *string
		if filter != nil {
			str := string(*filter)
			filterStr = &str
		}
		bookings, err = r.BookingService.GetBookingsByCleanerIDs([]string{cleaner.ID}, filterStr)
	} else {
		// Default to client bookings for CLIENT role or others
		if filter != nil {
			bookings, err = r.BookingService.GetClientBookingsFiltered(userID, string(*filter))
		} else {
			bookings, err = r.BookingService.GetClientBookings(userID)
		}
	}

	if err != nil {
		return nil, err
	}

	// Convert array
	result := make([]*model.Booking, len(bookings))
	for i, booking := range bookings {
		result[i] = convertBookingToGraphQL(booking)
	}

	return result, nil
}

// Booking is the resolver for the booking field.
func (r *queryResolver) Booking(ctx context.Context, id string) (*model.Booking, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Check if user is admin - if so, bypass authorization check
	user, err := r.AuthService.GetUserByID(userID)
	if err == nil && user != nil && user.Role == models.RolePlatformAdmin {
		// Admin can view any booking - call service method directly
		booking, err := r.BookingService.AdminGetBooking(id)
		if err != nil {
			return nil, err
		}
		return convertBookingToGraphQL(booking), nil
	}

	// For non-admin users, use normal authorization
	booking, err := r.BookingService.GetBooking(id, userID)
	if err != nil {
		return nil, err
	}

	return convertBookingToGraphQL(booking), nil
}

// GetPriceQuote is the resolver for the getPriceQuote field.
func (r *queryResolver) GetPriceQuote(ctx context.Context, input model.PriceQuoteInput) (*model.PriceQuote, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Handle optional areaSqm
	areaSqm := 0
	if input.AreaSqm != nil {
		areaSqm = *input.AreaSqm
	}

	// Handle optional frequency
	frequency := "one_time"
	if input.Frequency != nil {
		frequency = *input.Frequency
	}

	quote, err := r.PricingService.CalculatePrice(
		userID,
		models.ServiceType(input.ServiceType),
		areaSqm,
		input.EstimatedHours,
		input.ScheduledDate,
		input.ScheduledTime,
		input.IncludesWindows,
		input.NumberOfWindows,
		input.IncludesCarpet,
		input.CarpetAreaSqm,
		false, // includesFridge - not available in PriceQuoteInput (legacy)
		false, // includesOven - not available in PriceQuoteInput (legacy)
		false, // includesBalcony - not available in PriceQuoteInput (legacy)
		false, // includesSupplies - not available in PriceQuoteInput (legacy)
		frequency,
	)
	if err != nil {
		return nil, err
	}

	return &model.PriceQuote{
		BasePrice:      quote.BasePrice,
		AddonsPrice:    quote.AddonsPrice,
		Subtotal:       quote.Subtotal,
		Discount:       quote.Discount,
		PlatformFee:    quote.PlatformFee,
		TotalPrice:     quote.TotalPrice,
		CleanerPayout:  quote.CleanerPayout,
		EstimatedHours: quote.EstimatedHours,
		Breakdown: &model.PriceBreakdown{
			BasePricePerHour:      quote.Breakdown.BasePricePerHour,
			HoursCharged:          quote.Breakdown.HoursCharged,
			AreaPrice:             quote.Breakdown.AreaPrice,
			WindowsPrice:          quote.Breakdown.WindowsPrice,
			CarpetPrice:           quote.Breakdown.CarpetPrice,
			TimeMultiplier:        quote.Breakdown.TimeMultiplier,
			DiscountPercentage:    quote.Breakdown.DiscountPercentage,
			PlatformFeePercentage: quote.Breakdown.PlatformFeePercentage,
		},
	}, nil
}

// AvailableJobs is the resolver for the availableJobs field.
func (r *queryResolver) AvailableJobs(ctx context.Context, limit *int, offset *int, city *string) ([]*model.Booking, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	limitVal := 20
	offsetVal := 0
	cityVal := ""

	if limit != nil {
		limitVal = *limit
	}
	if offset != nil {
		offsetVal = *offset
	}
	if city != nil {
		cityVal = *city
	}

	bookings, err := r.BookingService.GetAvailableJobs(userID, cityVal, limitVal, offsetVal)
	if err != nil {
		return nil, err
	}

	// Convert array
	result := make([]*model.Booking, len(bookings))
	for i, booking := range bookings {
		result[i] = convertBookingToGraphQL(booking)
	}

	return result, nil
}

// Checkin is the resolver for the checkin field.
func (r *queryResolver) Checkin(ctx context.Context, bookingID string) (*model.Checkin, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	checkin, err := r.CheckinService.GetCheckinByBookingID(bookingID)
	if err != nil {
		return nil, err
	}

	if checkin == nil {
		return nil, nil
	}

	return convertCheckinToGraphQL(checkin), nil
}

// BookingPayments is the resolver for the bookingPayments field.
func (r *queryResolver) BookingPayments(ctx context.Context, bookingID string) ([]*model.Payment, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	payments, err := r.PaymentService.GetPaymentsByBooking(bookingID, userID)
	if err != nil {
		return nil, err
	}

	// Convert array
	result := make([]*model.Payment, len(payments))
	for i, payment := range payments {
		result[i] = convertPaymentToGraphQL(payment)
	}

	return result, nil
}

// Payment is the resolver for the payment field.
func (r *queryResolver) Payment(ctx context.Context, id string) (*model.Payment, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	payment, err := r.PaymentService.GetPayment(id, userID)
	if err != nil {
		return nil, err
	}

	return convertPaymentToGraphQL(payment), nil
}

// Invoice is the resolver for the invoice field.
func (r *queryResolver) Invoice(ctx context.Context, id string) (*model.Invoice, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	invoice, err := r.InvoiceService.GetInvoice(id, userID)
	if err != nil {
		return nil, err
	}

	return convertInvoiceToGraphQL(invoice), nil
}

// InvoiceByBooking is the resolver for the invoiceByBooking field.
func (r *queryResolver) InvoiceByBooking(ctx context.Context, bookingID string) (*model.Invoice, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	invoice, err := r.InvoiceService.GetInvoiceByBookingID(bookingID, userID)
	if err != nil {
		return nil, err
	}

	if invoice == nil {
		return nil, nil
	}

	return convertInvoiceToGraphQL(invoice), nil
}

// MyInvoices is the resolver for the myInvoices field.
func (r *queryResolver) MyInvoices(ctx context.Context) ([]*model.Invoice, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	invoices, err := r.InvoiceService.GetMyInvoices(userID)
	if err != nil {
		return nil, err
	}

	// Convert array
	result := make([]*model.Invoice, len(invoices))
	for i, invoice := range invoices {
		result[i] = convertInvoiceToGraphQL(invoice)
	}

	return result, nil
}

// ReviewByBooking is the resolver for the reviewByBooking field.
func (r *queryResolver) ReviewByBooking(ctx context.Context, bookingID string) (*model.Review, error) {
	review, err := r.ReviewService.GetReviewByBookingID(bookingID)
	if err != nil {
		return nil, err
	}

	if review == nil {
		return nil, nil
	}

	return convertReviewToGraphQL(review), nil
}

// CleanerReviews is the resolver for the cleanerReviews field.
func (r *queryResolver) CleanerReviews(ctx context.Context, cleanerID string, limit *int, offset *int) ([]*model.Review, error) {
	limitVal := 20
	offsetVal := 0

	if limit != nil {
		limitVal = *limit
	}
	if offset != nil {
		offsetVal = *offset
	}

	reviews, err := r.ReviewService.GetCleanerReviews(cleanerID, limitVal, offsetVal)
	if err != nil {
		return nil, err
	}

	// Convert array
	result := make([]*model.Review, len(reviews))
	for i, review := range reviews {
		result[i] = convertReviewToGraphQL(review)
	}

	return result, nil
}

// Dispute is the resolver for the dispute field.
func (r *queryResolver) Dispute(ctx context.Context, id string) (*model.Dispute, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	dispute, err := r.DisputeService.GetDispute(id, userID)
	if err != nil {
		return nil, err
	}

	if dispute == nil {
		return nil, nil
	}

	return convertDisputeToGraphQL(dispute), nil
}

// DisputeByBooking is the resolver for the disputeByBooking field.
func (r *queryResolver) DisputeByBooking(ctx context.Context, bookingID string) (*model.Dispute, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	dispute, err := r.DisputeService.GetDisputeByBookingID(bookingID, userID)
	if err != nil {
		return nil, err
	}

	if dispute == nil {
		return nil, nil
	}

	return convertDisputeToGraphQL(dispute), nil
}

// OpenDisputes is the resolver for the openDisputes field.
func (r *queryResolver) OpenDisputes(ctx context.Context, limit *int) ([]*model.Dispute, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Check if user is admin
	user, err := r.AuthService.GetUserByID(userID)
	if err != nil {
		return nil, err
	}
	if user == nil || user.Role != "PLATFORM_ADMIN" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	limitVal := 50
	if limit != nil {
		limitVal = *limit
	}

	disputes, err := r.DisputeService.GetOpenDisputes(limitVal)
	if err != nil {
		return nil, err
	}

	// Convert array
	result := make([]*model.Dispute, len(disputes))
	for i, dispute := range disputes {
		result[i] = convertDisputeToGraphQL(dispute)
	}

	return result, nil
}

// BookingPhotos is the resolver for the bookingPhotos field.
func (r *queryResolver) BookingPhotos(ctx context.Context, bookingID string) ([]*model.Photo, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	photos, err := r.PhotoService.GetPhotosByBookingID(bookingID)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Photo, len(photos))
	for i, photo := range photos {
		result[i] = convertPhotoToGraphQL(photo)
	}

	return result, nil
}

// DisputePhotos is the resolver for the disputePhotos field.
func (r *queryResolver) DisputePhotos(ctx context.Context, disputeID string) ([]*model.Photo, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	photos, err := r.PhotoService.GetPhotosByDisputeID(disputeID)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Photo, len(photos))
	for i, photo := range photos {
		result[i] = convertPhotoToGraphQL(photo)
	}

	return result, nil
}

// BookingMessages is the resolver for the bookingMessages field.
func (r *queryResolver) BookingMessages(ctx context.Context, bookingID string) ([]*model.Message, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	messages, err := r.MessagingService.GetBookingMessages(bookingID, userID)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Message, len(messages))
	for i, msg := range messages {
		result[i] = convertMessageToGraphQL(msg)
	}

	return result, nil
}

// MyConversations is the resolver for the myConversations field.
func (r *queryResolver) MyConversations(ctx context.Context) ([]*model.Message, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	messages, err := r.MessagingService.GetMyConversations(userID)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Message, len(messages))
	for i, msg := range messages {
		result[i] = convertMessageToGraphQL(msg)
	}

	return result, nil
}

// UnreadMessagesCount is the resolver for the unreadMessagesCount field.
func (r *queryResolver) UnreadMessagesCount(ctx context.Context) (int, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return 0, fmt.Errorf("authentication required")
	}

	count, err := r.MessagingService.GetUnreadCount(userID)
	if err != nil {
		return 0, err
	}

	return count, nil
}

// BookingUnreadCount is the resolver for the bookingUnreadCount field.
func (r *queryResolver) BookingUnreadCount(ctx context.Context, bookingID string) (int, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return 0, fmt.Errorf("authentication required")
	}

	count, err := r.MessagingService.GetUnreadCountForBooking(bookingID, userID)
	if err != nil {
		return 0, err
	}

	return count, nil
}

// MyPayouts is the resolver for the myPayouts field.
func (r *queryResolver) MyPayouts(ctx context.Context, limit *int, offset *int) ([]*model.Payout, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	limitVal := 10
	offsetVal := 0
	if limit != nil {
		limitVal = *limit
	}
	if offset != nil {
		offsetVal = *offset
	}

	payouts, err := r.PayoutService.GetPayoutsByCleanerID(userID, limitVal, offsetVal)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Payout, len(payouts))
	for i, payout := range payouts {
		result[i] = convertPayoutToGraphQL(payout)
	}

	return result, nil
}

// Payout is the resolver for the payout field.
func (r *queryResolver) Payout(ctx context.Context, id string) (*model.Payout, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	payout, lineItems, err := r.PayoutService.GetPayoutWithLineItems(id)
	if err != nil {
		return nil, err
	}
	if payout == nil {
		return nil, nil
	}

	// Check authorization (only cleaner or admin can view)
	user, err := r.AuthService.GetUserByID(userID)
	if err != nil {
		return nil, err
	}
	if payout.CleanerID != userID && user.Role != "PLATFORM_ADMIN" {
		return nil, fmt.Errorf("unauthorized: you can only view your own payouts")
	}

	return convertPayoutToGraphQLWithLineItems(payout, lineItems), nil
}

// PendingPayouts is the resolver for the pendingPayouts field.
func (r *queryResolver) PendingPayouts(ctx context.Context) ([]*model.Payout, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Check if user is admin
	user, err := r.AuthService.GetUserByID(userID)
	if err != nil {
		return nil, err
	}
	if user == nil || user.Role != "PLATFORM_ADMIN" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	payouts, err := r.PayoutService.GetPendingPayouts()
	if err != nil {
		return nil, err
	}

	result := make([]*model.Payout, len(payouts))
	for i, payout := range payouts {
		result[i] = convertPayoutToGraphQL(payout)
	}

	return result, nil
}

// Payouts is the resolver for the payouts field.
func (r *queryResolver) Payouts(ctx context.Context, status *model.PayoutStatus, limit *int, offset *int) ([]*model.Payout, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Check if user is admin
	user, err := r.AuthService.GetUserByID(userID)
	if err != nil {
		return nil, err
	}
	if user == nil || user.Role != "PLATFORM_ADMIN" {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	// Convert status to string if provided
	var statusStr string
	if status != nil {
		statusStr = status.String()
	}

	payouts, err := r.PayoutService.GetPayoutsByStatus(statusStr, limit, offset)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Payout, len(payouts))
	for i, payout := range payouts {
		result[i] = convertPayoutToGraphQL(payout)
	}

	return result, nil
}

// MyAvailability is the resolver for the myAvailability field.
func (r *queryResolver) MyAvailability(ctx context.Context) ([]*model.Availability, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Get cleaner profile
	cleaner, err := r.CleanerService.GetOrCreateCleanerProfile(userID)
	if err != nil {
		return nil, err
	}

	availabilities, err := r.AvailabilityService.GetCleanerAvailability(cleaner.ID, userID)
	if err != nil {
		return nil, err
	}

	// Convert array
	result := make([]*model.Availability, len(availabilities))
	for i, avail := range availabilities {
		result[i] = convertAvailabilityToGraphQL(avail)
	}

	return result, nil
}

// MyCompanies is the resolver for the myCompanies field.
func (r *queryResolver) MyCompanies(ctx context.Context) ([]*model.Company, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	companies, err := r.CompanyService.GetMyCompanies(userID)
	if err != nil {
		return nil, err
	}

	// Convert array
	result := make([]*model.Company, len(companies))
	for i, company := range companies {
		result[i] = convertCompanyToGraphQL(company)
	}

	return result, nil
}

// Company is the resolver for the company field.
func (r *queryResolver) Company(ctx context.Context, id string) (*model.Company, error) {
	company, err := r.CompanyService.GetCompany(id)
	if err != nil {
		return nil, err
	}

	return convertCompanyToGraphQL(company), nil
}

// CompanyTeam is the resolver for the companyTeam field.
func (r *queryResolver) CompanyTeam(ctx context.Context, companyID string) ([]*model.CompanyCleaner, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	cleaners, err := r.CompanyService.GetCompanyTeam(companyID, userID)
	if err != nil {
		return nil, err
	}

	// Convert array
	result := make([]*model.CompanyCleaner, len(cleaners))
	for i, cleaner := range cleaners {
		result[i] = convertCompanyCleanerToGraphQL(cleaner, r.Resolver)
	}

	return result, nil
}

// CompanyBookings is the resolver for the companyBookings field.
func (r *queryResolver) CompanyBookings(ctx context.Context, companyID string, filter *model.BookingFilter) ([]*model.Booking, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Verify user is admin of this company
	companies, err := r.CompanyService.GetUserCompanies(userID)
	if err != nil {
		return nil, err
	}

	isAdmin := false
	for _, company := range companies {
		if company.ID == companyID {
			isAdmin = true
			break
		}
	}

	if !isAdmin {
		return nil, fmt.Errorf("unauthorized: not an admin of this company")
	}

	// Get company team cleaners
	cleaners, err := r.CompanyService.GetCompanyTeam(companyID, userID)
	if err != nil {
		return nil, err
	}

	// Get all cleaner IDs
	cleanerIDs := make([]string, 0)
	for _, cleaner := range cleaners {
		cleanerIDs = append(cleanerIDs, cleaner.CleanerID)
	}

	// Get bookings for all team cleaners
	var filterStr *string
	if filter != nil {
		str := string(*filter)
		filterStr = &str
	}
	bookings, err := r.BookingService.GetBookingsByCleanerIDs(cleanerIDs, filterStr)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	result := make([]*model.Booking, len(bookings))
	for i, booking := range bookings {
		result[i] = convertBookingToGraphQL(booking)
	}

	return result, nil
}

// CompanyStats is the resolver for the companyStats field.
func (r *queryResolver) CompanyStats(ctx context.Context, companyID string) (*model.CompanyStats, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Verify user is admin of this company
	companies, err := r.CompanyService.GetUserCompanies(userID)
	if err != nil {
		return nil, err
	}

	isAdmin := false
	for _, company := range companies {
		if company.ID == companyID {
			isAdmin = true
			break
		}
	}

	if !isAdmin {
		return nil, fmt.Errorf("unauthorized: not an admin of this company")
	}

	stats, err := r.CompanyService.GetCompanyStats(companyID)
	if err != nil {
		return nil, err
	}

	return &model.CompanyStats{
		TotalTeamMembers:  stats.TotalTeamMembers,
		ActiveTeamMembers: stats.ActiveTeamMembers,
		TotalBookings:     stats.TotalBookings,
		ActiveBookings:    stats.ActiveBookings,
		CompletedBookings: stats.CompletedBookings,
		TotalRevenue:      stats.TotalRevenue,
		MonthlyRevenue:    stats.MonthlyRevenue,
		AverageRating:     stats.AverageRating,
	}, nil
}

// CompanyInvoices is the resolver for the companyInvoices field.
func (r *queryResolver) CompanyInvoices(ctx context.Context, companyID string) ([]*model.Invoice, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	// Verify user is admin of this company
	companies, err := r.CompanyService.GetUserCompanies(userID)
	if err != nil {
		return nil, err
	}

	isAdmin := false
	for _, company := range companies {
		if company.ID == companyID {
			isAdmin = true
			break
		}
	}

	if !isAdmin {
		return nil, fmt.Errorf("unauthorized: not an admin of this company")
	}

	// Get company team cleaners
	cleaners, err := r.CompanyService.GetCompanyTeam(companyID, userID)
	if err != nil {
		return nil, err
	}

	// Get all cleaner IDs
	cleanerIDs := make([]string, 0)
	for _, cleaner := range cleaners {
		cleanerIDs = append(cleanerIDs, cleaner.CleanerID)
	}

	// Get bookings for all team cleaners
	bookings, err := r.BookingService.GetBookingsByCleanerIDs(cleanerIDs, nil)
	if err != nil {
		return nil, err
	}

	// Get invoices for these bookings
	var invoices []*model.Invoice
	for _, booking := range bookings {
		invoice, err := r.InvoiceService.GetInvoiceByBookingID(booking.ID, userID)
		if err != nil {
			continue // Skip if error
		}
		if invoice != nil {
			invoices = append(invoices, convertInvoiceToGraphQL(invoice))
		}
	}

	return invoices, nil
}

// Cleaners is the resolver for the cleaners field.
func (r *queryResolver) Cleaners(ctx context.Context, limit *int, offset *int, status *model.ApprovalStatus, search *string) ([]*model.Cleaner, error) {
	// Check if user is authenticated (admin only)
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	role, ok := middleware.GetUserRoleFromContext(ctx)
	if !ok || role != "PLATFORM_ADMIN" {
		return nil, fmt.Errorf("admin access required")
	}

	// Set defaults
	defaultLimit := 100
	defaultOffset := 0

	if limit == nil {
		limit = &defaultLimit
	}
	if offset == nil {
		offset = &defaultOffset
	}

	// Convert status to string if provided
	var statusStr *string
	if status != nil {
		str := string(*status)
		statusStr = &str
	}

	cleaners, err := r.CleanerService.GetCleaners(*limit, *offset, statusStr, search)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Cleaner, len(cleaners))
	for i, cleaner := range cleaners {
		result[i] = convertCleanerToGraphQL(cleaner)
	}

	return result, nil
}

// Companies is the resolver for the companies field.
func (r *queryResolver) Companies(ctx context.Context, limit *int, offset *int, status *model.CompanyApprovalStatus, search *string) ([]*model.Company, error) {
	// Check if user is authenticated (admin only)
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	role, ok := middleware.GetUserRoleFromContext(ctx)
	if !ok || role != "PLATFORM_ADMIN" {
		return nil, fmt.Errorf("admin access required")
	}

	// Set defaults
	defaultLimit := 100
	defaultOffset := 0

	if limit == nil {
		limit = &defaultLimit
	}
	if offset == nil {
		offset = &defaultOffset
	}

	// Convert status to string if provided
	var statusStr *string
	if status != nil {
		str := string(*status)
		statusStr = &str
	}

	companies, err := r.CompanyService.GetCompanies(*limit, *offset, statusStr, search)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Company, len(companies))
	for i, company := range companies {
		result[i] = convertCompanyToGraphQL(company)
	}

	return result, nil
}

// PendingCleaners is the resolver for the pendingCleaners field.
func (r *queryResolver) PendingCleaners(ctx context.Context) ([]*model.Cleaner, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	cleaners, err := r.CleanerService.GetPendingCleaners()
	if err != nil {
		return nil, err
	}

	var result []*model.Cleaner
	for _, cleaner := range cleaners {
		result = append(result, convertCleanerToGraphQL(cleaner))
	}

	return result, nil
}

// PendingCompanies is the resolver for the pendingCompanies field.
func (r *queryResolver) PendingCompanies(ctx context.Context) ([]*model.Company, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	companies, err := r.CompanyService.GetPendingCompanies()
	if err != nil {
		return nil, err
	}

	var result []*model.Company
	for _, company := range companies {
		result = append(result, convertCompanyToGraphQL(company))
	}

	return result, nil
}

// PlatformSettings is the resolver for the platformSettings field.
func (r *queryResolver) PlatformSettings(ctx context.Context) (*model.PlatformSettings, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	settings, err := r.PlatformSettingsService.GetSettings(ctx)
	if err != nil {
		return nil, err
	}

	return convertPlatformSettingsToGraphQL(settings), nil
}

// CleanerStats is the resolver for the cleanerStats field.
func (r *queryResolver) CleanerStats(ctx context.Context, cleanerID string) (*model.CleanerStats, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	stats, err := r.CleanerService.GetCleanerStats(cleanerID)
	if err != nil {
		return nil, err
	}

	return convertCleanerStatsToGraphQL(stats), nil
}

// CleanerAvailability is the resolver for the cleanerAvailability field.
func (r *queryResolver) CleanerAvailability(ctx context.Context, cleanerID string) ([]*model.Availability, error) {
	// Require admin authorization
	adminID, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	availability, err := r.AvailabilityService.GetCleanerAvailability(cleanerID, adminID)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL models
	result := make([]*model.Availability, len(availability))
	for i, avail := range availability {
		result[i] = convertAvailabilityToGraphQL(avail)
	}

	return result, nil
}

// CleanerBookings is the resolver for the cleanerBookings field.
func (r *queryResolver) CleanerBookings(ctx context.Context, cleanerID string, filter *model.BookingFilter) ([]*model.Booking, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	// Get bookings for this cleaner
	limit := 100
	offset := 0

	bookings, err := r.BookingService.GetCleanerBookingsAdmin(cleanerID, limit, offset, nil, nil)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL models
	result := make([]*model.Booking, len(bookings))
	for i, booking := range bookings {
		result[i] = convertBookingToGraphQL(booking)
	}

	return result, nil
}

// CleanerPayouts is the resolver for the cleanerPayouts field.
func (r *queryResolver) CleanerPayouts(ctx context.Context, cleanerID string, limit *int) ([]*model.Payout, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	limitVal := 50 // Default limit
	if limit != nil {
		limitVal = *limit
	}

	payouts, err := r.PayoutService.GetCleanerPayouts(cleanerID, limitVal)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL models
	result := make([]*model.Payout, len(payouts))
	for i, payout := range payouts {
		result[i] = convertPayoutToGraphQL(payout)
	}

	return result, nil
}

// AdminKPIs is the resolver for the adminKPIs field.
func (r *queryResolver) AdminKPIs(ctx context.Context, period model.KPIPeriod) (*model.AdminKPIs, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	kpis, err := r.AdminAnalyticsService.GetKPIs(period)
	if err != nil {
		return nil, err
	}

	return kpis, nil
}

// AllBookingsAdmin is the resolver for the allBookingsAdmin field.
func (r *queryResolver) AllBookingsAdmin(ctx context.Context, limit *int, offset *int, status *model.BookingStatus, search *string) ([]*model.Booking, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	limitVal := 50 // Default limit
	offsetVal := 0
	if limit != nil {
		limitVal = *limit
	}
	if offset != nil {
		offsetVal = *offset
	}

	// Convert GraphQL BookingStatus to models.BookingStatus
	var modelStatus *models.BookingStatus
	if status != nil {
		s := models.BookingStatus(*status)
		modelStatus = &s
	}

	bookings, err := r.AdminAnalyticsService.GetAllBookingsAdmin(limitVal, offsetVal, modelStatus, search)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL models
	result := make([]*model.Booking, len(bookings))
	for i, booking := range bookings {
		result[i] = convertBookingToGraphQL(booking)
	}

	return result, nil
}

// PlatformStats is the resolver for the platformStats field.
func (r *queryResolver) PlatformStats(ctx context.Context) (*model.PlatformStats, error) {
	// This is a public endpoint - no authentication required for landing page stats
	stats, err := r.AdminAnalyticsService.GetPlatformStats()
	if err != nil {
		return nil, fmt.Errorf("failed to get platform stats: %w", err)
	}
	return stats, nil
}

// CalculateBookingPrice is the resolver for the calculateBookingPrice field.
func (r *queryResolver) CalculateBookingPrice(ctx context.Context, input model.PriceCalculationInput) (*model.PriceQuote, error) {
	// Get user ID from context (empty string if not authenticated)
	clientID, _ := middleware.GetUserIDFromContext(ctx)

	// Parse service type
	serviceType := models.ServiceType(input.CleaningType)

	// Parse area size
	areaSqm := 0
	if input.AreaSize != nil {
		areaSqm = *input.AreaSize
	}

	// Parse duration hours
	estimatedHours := 0
	if input.DurationHours != nil {
		estimatedHours = int(*input.DurationHours)
	}

	// Parse scheduled date and time
	var scheduledDate, scheduledTime time.Time
	if input.ScheduledDate != nil {
		// Parse date string (format: YYYY-MM-DD)
		t, err := time.Parse("2006-01-02", *input.ScheduledDate)
		if err == nil {
			scheduledDate = t
		}
	}
	if input.ScheduledStartTime != nil {
		scheduledTime = *input.ScheduledStartTime
	}

	// Parse windows
	includesWindows := false
	numberOfWindows := 0
	if input.IncludesWindows != nil {
		includesWindows = *input.IncludesWindows
	}
	if input.NumberOfWindows != nil {
		numberOfWindows = *input.NumberOfWindows
	}

	// Parse carpet
	includesCarpet := false
	carpetAreaSqm := 0
	if input.IncludesCarpet != nil {
		includesCarpet = *input.IncludesCarpet
	}
	if input.CarpetAreaSqm != nil {
		carpetAreaSqm = *input.CarpetAreaSqm
	}

	// Parse frequency
	frequency := "one_time"
	if input.Frequency != nil {
		frequency = *input.Frequency
	}

	// Parse additional addons
	includesFridge := false
	if input.IncludesFridge != nil {
		includesFridge = *input.IncludesFridge
	}
	includesOven := false
	if input.IncludesOven != nil {
		includesOven = *input.IncludesOven
	}
	includesBalcony := false
	if input.IncludesBalcony != nil {
		includesBalcony = *input.IncludesBalcony
	}
	includesSupplies := false
	if input.IncludesSupplies != nil {
		includesSupplies = *input.IncludesSupplies
	}

	// Use PricingService for price calculation
	quote, err := r.PricingService.CalculatePrice(
		clientID,
		serviceType,
		areaSqm,
		estimatedHours,
		scheduledDate,
		scheduledTime,
		includesWindows,
		numberOfWindows,
		includesCarpet,
		carpetAreaSqm,
		includesFridge,
		includesOven,
		includesBalcony,
		includesSupplies,
		frequency,
	)
	if err != nil {
		return nil, err
	}

	// Convert PriceQuote to GraphQL PriceQuote
	return &model.PriceQuote{
		BasePrice:      quote.BasePrice,
		AddonsPrice:    quote.AddonsPrice,
		Subtotal:       quote.Subtotal,
		Discount:       quote.Discount,
		PlatformFee:    quote.PlatformFee,
		TotalPrice:     quote.TotalPrice,
		CleanerPayout:  quote.CleanerPayout,
		EstimatedHours: quote.EstimatedHours,
		Breakdown: &model.PriceBreakdown{
			BasePricePerHour:      quote.Breakdown.BasePricePerHour,
			HoursCharged:          quote.Breakdown.HoursCharged,
			AreaPrice:             quote.Breakdown.AreaPrice,
			WindowsPrice:          quote.Breakdown.WindowsPrice,
			CarpetPrice:           quote.Breakdown.CarpetPrice,
			TimeMultiplier:        quote.Breakdown.TimeMultiplier,
			DiscountPercentage:    quote.Breakdown.DiscountPercentage,
			PlatformFeePercentage: quote.Breakdown.PlatformFeePercentage,
		},
	}, nil
}

// CleanerApplication is the resolver for the cleanerApplication field.
func (r *queryResolver) CleanerApplication(ctx context.Context, sessionID string) (*model.CleanerApplication, error) {
	app, err := r.CleanerApplicationService.GetBySessionID(sessionID)
	if err != nil {
		return nil, err
	}
	return convertCleanerApplicationToGraphQL(app), nil
}

// MyCleanerApplication is the resolver for the myCleanerApplication field.
func (r *queryResolver) MyCleanerApplication(ctx context.Context) (*model.CleanerApplication, error) {
	userID, ok := middleware.GetUserIDFromContext(ctx)
	if !ok || userID == "" {
		return nil, fmt.Errorf("authentication required")
	}

	app, err := r.CleanerApplicationService.GetByUserID(userID)
	if err != nil {
		return nil, err
	}
	return convertCleanerApplicationToGraphQL(app), nil
}

// CalculateEarnings is the resolver for the calculateEarnings field.
func (r *queryResolver) CalculateEarnings(ctx context.Context, hoursPerWeek string, areas []string) (*model.EarningPotential, error) {
	potential, err := r.CleanerApplicationService.CalculateEarnings(hoursPerWeek, areas)
	if err != nil {
		return nil, err
	}

	return &model.EarningPotential{
		WeeklyMin:         potential.WeeklyMin,
		WeeklyMax:         potential.WeeklyMax,
		MonthlyMin:        potential.MonthlyMin,
		MonthlyMax:        potential.MonthlyMax,
		BaseRate:          potential.BaseRate,
		TopCleanerMonthly: potential.TopCleanerMonthly,
	}, nil
}

// PendingApplications is the resolver for the pendingApplications field.
func (r *queryResolver) PendingApplications(ctx context.Context, limit *int, offset *int) ([]*model.CleanerApplication, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	limitVal := 20
	offsetVal := 0
	if limit != nil {
		limitVal = *limit
	}
	if offset != nil {
		offsetVal = *offset
	}

	apps, err := r.CleanerApplicationService.GetPendingApplications(limitVal, offsetVal)
	if err != nil {
		return nil, err
	}

	result := make([]*model.CleanerApplication, len(apps))
	for i, app := range apps {
		result[i] = convertCleanerApplicationToGraphQL(app)
	}
	return result, nil
}

// PendingCleanerApplications is the resolver for the pendingCleanerApplications field.
func (r *queryResolver) PendingCleanerApplications(ctx context.Context) ([]*model.CleanerApplication, error) {
	// Require admin authorization
	_, err := middleware.RequireAdmin(ctx)
	if err != nil {
		return nil, err
	}

	// Get all pending applications (no pagination for this endpoint)
	apps, err := r.CleanerApplicationService.GetPendingApplications(100, 0)
	if err != nil {
		return nil, err
	}

	result := make([]*model.CleanerApplication, len(apps))
	for i, app := range apps {
		result[i] = convertCleanerApplicationToGraphQL(app)
	}
	return result, nil
}

// Booking returns generated.BookingResolver implementation.
func (r *Resolver) Booking() generated.BookingResolver { return &bookingResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type bookingResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
